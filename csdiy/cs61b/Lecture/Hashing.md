用 Search Tree 等数据结构实现 sets 的限制：
当使用 ST 的数据结构时，我们要求 item 必须要可比（实现 Comparable 接口），如果 sets 中的元素是不可比的呢
ST 的时间复杂度为 logN 数量级，是否还能做得更好
我们需要的事让 add 和 contain 这两个方法变得更快
我们可以考虑分成几个区域，每次需要找的时候，我们就去特定的区域找，这样可以节省时间
对于每一个区域，分配一个链表结构用于存储该区域的 item
假设，区域的数量 M 是固定的，那么平均每个区域有 N/M 个 item，找到他们的时间复杂度也为 N/M 数量级，就算区域内部采用树等结构，最快也是 log (N/M) 数量级，但因为 M 是常数，所以其实与之前 logN 没有差别
如果我们提前将 M 取得很大，因为每个区域都至少会占用一个位置，这会导致空间的浪费（个人理解）
所以，我们需要找到一种方法，让 M 可以不断的增加，使他能够追上 N 的数量级，这样查找时的平均时间复杂度将是常数级别
目标：使得 N/M 保持小于一个常数 k
当检测到 N/M 大于 k 时，进行扩容操作
如何扩容呢，每次以一定的 factor 倍增加 M

哈希值
对于整数，我们能够采取 value%M 的方式将它分为 M 类
现在考虑，如果是字符串，应该如何将他分类呢
我们是否通过某种函数将每个字符串转换成一个数字呢，这种函数就称为 hashCode

在 java 中，每个类都需要实现 java 中的 hashcode 方法，如果不实现，会自动返回该对象的内存地址相关的某个函数作为哈希值
如果使用默认的 hashcode 方法，那么在不同次运行程序的过程中，同一对象的哈希值会因为分配的内存地址不同而不同

为什么用默认的 hashcode 方法不好？
假设新建一个 User 类，我们可能根据他的手机号码字符串识别是否为同样的 User，但当使用 contains 方法时，会优先从根据 hashcode 去对应的区域去寻找，因为内存地址分配是随机的，只有 1/M 的机会找到正确的箱子从而找到该 User
正确的做法：实现某种 hashcode 方法，使得手机号与哈希值一一对应，之后进行 equals 判断时才能得到一致的结果

哈希表要求键（Key）是不可变的
为了保证键的哈希值在存入哈希表后保持不变，从而确保数据能够被正确地存储、查找和删除