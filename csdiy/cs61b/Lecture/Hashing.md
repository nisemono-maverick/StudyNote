用 Search Tree 等数据结构实现 sets 的限制：
当使用 ST 的数据结构时，我们要求 item 必须要可比（实现 Comparable 接口），如果 sets 中的元素是不可比的呢
ST 的时间复杂度为 logN 数量级，是否还能做得更好
我们需要的事让 add 和 contain 这两个方法变得更快
我们可以考虑分成几个区域，每次需要找的时候，我们就去特定的区域找，这样可以节省时间
对于每一个区域，分配一个链表结构用于存储该区域的 item
假设，区域的数量 M 是固定的，那么平均每个区域有 N/M 个 item，找到他们的时间复杂度也为 N/M 数量级，就算区域内部采用树等结构，最快也是 log (N/M) 数量级，但因为 M 是常数，所以其实与之前 logN 没有差别
如果我们提前将 M 取得很大，因为每个区域都至少会占用一个位置，这会导致空间的浪费（个人理解）
所以，我们需要找到一种方法，让 M 可以不断的增加，使他能够追上 N 的数量级，这样查找时的平局时间复杂度将是常数级别
目标：使得 N/M 保持小于一个常数 k
当检测到 N/M 大于 k 时，进行扩容操作
如何扩容呢，每次以一定的 factor 倍增加 M

对于整数，我们能够采取 value%M 的方式将它分为 M 类
现在考虑，如果是字符串，应该如何将他分类呢
我们是否通过某种函数将每个字符串转换成一个数字呢，这种函数就称为 hashCode

在 java 中，每个类都需要实现 java 中的 hashcode 方法，如果不实现，会自动返回