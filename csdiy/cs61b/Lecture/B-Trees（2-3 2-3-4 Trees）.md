BST 在最坏的情形下，可能会退化为链表（因为我们可能会不断添加叶节点，使树深度越来越大）
一个大胆的想法：改变一个节点只能放一个 item 的格局，不增加新的叶节点来增加深度，而是往已有的叶节点增添 item 的方式
那么如何避免一个叶子被塞入特别多 item 的问题？
解决方式：设定最大数量限制 L，比如 L=3，一个叶子中最多放 3 个 item
如果某个节点超过了最大限制，将其中一个元素放入其父节点中
那么到底要选哪个呢？
选择中间靠左的元素，加入到父节点中，这样其他元素自然的会被分为 2 颗子树，如图，此时父节点有 3 颗子树
![[Pasted image 20260104165106.png]]
链式反应，如果将元素调整加入父节点的过程使得父节点也超过了最大数量限制，则对父节点也做相应的操作
那如果根节点超出了数量限制呢？将选择的元素作为新的根节点，其它元素相似裂变，此时树的高度+1

B-Trees 在 2 中情形下常用：
1. L 很小，2 或 3，用于作为 simple balanced search tree
2. L 很大，通常为千数量级，常用于数据库和文件系统中

2-3-4 树，即是 B 树在 L=3 时的特例
其中 3 代表它一个节点中最多含有 3 个元素
其中 4 代表一个节点最多有 4 个子树
（剧透：每个 2-3 树都能一一转化为一颗对应的红黑树）
