图
图包含一组节点，一组边，每条边连接 2 个节点
树可以看成有限制的图
![[Pasted image 20260112204706.png]]
简单图（大部分情况下，提到图时指的是简单图）
没有链接到自己的边，也就是没有长度为 1 的环
不会有两条边连接 2 个同样的节点，也就是没有平行的边

![[Pasted image 20260112205053.png]]
### 1. 按边的方向性分类

| 类别      | 核心定义         | 关键特征                                       | 现实比喻                                                          |
| :------ | :----------- | :----------------------------------------- | :------------------------------------------------------------ |
| **无向图** | 边没有方向，只表示连接。 | 关系是**双向、对称**的。一条边 `(A, B)` 意味着 A 和 B 平等相连。 | **好友关系**（互为好友）、**道路网**（默认双车道）、**分子结构**。                       |
| **有向图** | 边有方向，用箭头表示。  | 关系是**单向、不对称**的。一条边 `A -> B` 表示从 A 到 B。     | **关注关系**（A 关注 B）、**网页超链接**（从 A 页链接到 B 页）、**任务依赖**（A 完成才能做 B）。 |

### 2. 按图中是否包含“环”分类

| 类别 | 核心定义 | 关键特征 | 重要性 |
| :--- | :--- | :--- | :--- |
| **无环图** | 图中**不存在**任何环（循环路径）。 | 沿着边的方向/连接走下去，**不可能回到起点**。 | 结构简单，代表严格的依赖或层次关系。 |
| **有环图** | 图中**存在至少一个**环。 | 可以从某点出发，沿着边最终回到该点。 | 更普遍，能表示循环、反馈和复杂网络关系。 |

 “with edge labels”（带边标签的图）：它指的是在图的每条边上，除了连接关系本身，还附加了一个额外的数据，称为**标签**。

关于图的常见问题
从 S 节点到 T 节点的最短路径？无环的最长路径？
图中存在环（cycle）吗
是否有一种方法访问所有站点，并且每条边恰好使用一次（一笔画）
s-t Path：有一条路径（path）从 s 节点到 t 节点吗
Connectivity：图是否连通，即是否每个节点之间都有一条路径
Biconnectivity：是否有个节点，移除后图就不再连通
Shortest s-t Path：从 S 节点到 T 节点的最短路径
Cycle Detection：图中是否存在环
Euler Tour：经过图中每条边恰好一次的路径
Hamilton Tour：经过图中每个顶点恰好一次的路径
Planarity: 一个图能否在**二维平面上绘制**，且满足 **“边与边之间除了在顶点处相交外，不在任何其他位置交叉”** 的性质。
Isomorphism: 两个图是否同构

先来解决其中一个问题 s-t Connectivity：s 和 t 之间是否有一条路径
我们需要以某种方式遍历图
一个算法
```java
isconnected(Node s,Node t):
	if (s == t):
	    return true;
	
	for child in neighbors(s):
	    if isconnected(child, t):
	        return true;
	
	return false;
```
其中的错误：可能造成循环
解决方式，标记已经出现过的节点，跳过他
```java
isconnected(Node s,Node t):
	mark s;
	if (s == t):
	    return true;
	
	for child in unmarked_neighbors(s):
	    if isconnected(child, t):
	        return true;
	
	return false;
```

我们刚刚做的操作，就是 Depth First Search（DFS）
之所以叫深度优先，是因为在探索另一个邻近子图前，总是会把这个子图探索完，即往深度探索

Depth First Paths
```
dfs(v):
	mark v;
	for w in unmarked_neighbors(v):
		set edgeTo[w] = v;
		dfs(w);
```