## 策略模式在文件处理中的应用

### 原始代码的问题

#### 初始实现
```python
class FileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file_type = file_path.split('.')[-1]
    
    def process_excel(self):
        print('Processing excel file')
        
    def process_csv(self):
        print('Processing csv file')
        
    def process_txt(self):
        print('Processing txt file')
        
    def process_file(self):
        if self.file_type == 'xlsx':
            self.process_excel()
        elif self.file_type == 'csv':
            self.process_csv()
        elif self.file_type == 'txt':
            self.process_txt()
```

#### 主要缺点
1. **违反开闭原则**：增加新的文件类型需要修改`process_file`方法
2. **职责过重**：一个类承担了多种文件类型的处理逻辑
3. **代码臃肿**：随着支持的文件类型增多，类会变得越来越庞大
4. **难以维护**：条件判断语句会越来越复杂

### 策略模式解决方案

#### 核心思想
将不同的算法（策略）封装在独立的类中，使它们可以互相替换，让算法的变化独立于使用算法的客户端。

#### 实现结构

```python
from abc import ABC, abstractmethod

# 1. 定义策略接口
class ProcessStrategy(ABC):
    @abstractmethod
    def process_file(self, filepath):
        pass

# 2. 实现具体策略
class ExcelProcessStrategy(ProcessStrategy):
    def process_file(self, filepath):
        print('Processing excel file')
        # 实际的Excel处理逻辑
        
class CsvProcessStrategy(ProcessStrategy):
    def process_file(self, filepath):
        print('Processing csv file')
        # 实际的CSV处理逻辑
        
class TxtProcessStrategy(ProcessStrategy):
    def process_file(self, filepath):
        print('Processing txt file')
        # 实际的TXT处理逻辑

# 3. 上下文类 - 负责使用策略
class FileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file_type = file_path.split('.')[-1]
        self.strategy = self._get_strategy()
    
    def _get_strategy(self) -> ProcessStrategy:
        """根据文件类型选择合适的策略"""
        strategy_map = {
            'xlsx': ExcelProcessStrategy(),
            'csv': CsvProcessStrategy(),
            'txt': TxtProcessStrategy()
        }
        return strategy_map.get(self.file_type)
    
    def process_file(self):
        if self.strategy:
            self.strategy.process_file(self.file_path)
        else:
            raise ValueError(f"Unsupported file type: {self.file_type}")
```

#### 进一步优化：使用工厂模式

```python
class StrategyFactory:
    @staticmethod
    def create_strategy(file_type: str) -> ProcessStrategy:
        strategies = {
            'xlsx': ExcelProcessStrategy,
            'csv': CsvProcessStrategy,
            'txt': TxtProcessStrategy,
            'xls': ExcelProcessStrategy  # 支持更多扩展
        }
        
        strategy_class = strategies.get(file_type)
        if strategy_class:
            return strategy_class()
        else:
            raise ValueError(f"No strategy found for file type: {file_type}")

class FileProcessor:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file_type = file_path.split('.')[-1].lower()
        self.strategy = StrategyFactory.create_strategy(self.file_type)
    
    def process_file(self):
        self.strategy.process_file(self.file_path)
```

### 策略模式的优点

#### 1. 符合开闭原则
```python
# 新增PDF处理策略，无需修改现有代码
class PdfProcessStrategy(ProcessStrategy):
    def process_file(self, filepath):
        print('Processing pdf file')

# 只需在工厂中注册新策略
StrategyFactory.strategies['pdf'] = PdfProcessStrategy
```

#### 2. 消除条件判断
- 使用多态代替条件语句
- 代码更清晰，易于理解和维护

#### 3. 更好的代码组织
- 每个策略职责单一
- 易于单元测试
- 便于代码复用

#### 4. 运行时策略切换
```python
class FileProcessor:
    def set_strategy(self, strategy: ProcessStrategy):
        self.strategy = strategy
    
    def process_file(self):
        self.strategy.process_file(self.file_path)
```

### 实际应用扩展

#### 支持配置化策略选择
```python
class ConfigurableFileProcessor:
    def __init__(self, file_path, config):
        self.file_path = file_path
        self.config = config
        self.strategy = self._create_strategy_from_config()
    
    def _create_strategy_from_config(self):
        file_type = self.file_path.split('.')[-1]
        strategy_class = self.config.get_strategy(file_type)
        return strategy_class()
```

#### 组合策略模式
```python
class CompositeProcessStrategy(ProcessStrategy):
    def __init__(self):
        self.strategies = []
    
    def add_strategy(self, strategy: ProcessStrategy):
        self.strategies.append(strategy)
    
    def process_file(self, filepath):
        for strategy in self.strategies:
            strategy.process_file(filepath)
```

### 总结

策略模式通过将算法封装在独立的类中，解决了以下问题：

- **扩展性**：新增文件类型处理无需修改现有代码
- **维护性**：每个策略类职责单一，易于维护和测试
- **灵活性**：可以在运行时动态切换处理策略
- **可读性**：消除了复杂的条件判断逻辑